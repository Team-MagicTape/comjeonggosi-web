# 디지털 논리 기초

## 이진수, 부울 대수

### 이진수란?
0과 1만으로 모든 수를 표현하는 방식이다.  
숫자가 1을 넘어가면 자리 올림을 한다.

### 이진수 표현 방식
만약 10이라는 숫자가 십진수 10인지 이진수 10인지 헷갈릴 수 있기 때문에  
아래 첨자로 `10(2)`라고 표기하거나 `0b10`처럼 `0b`(binary)를 붙여 이진수라는 것을 표기한다.

### 이진수의 음수 표현
가장 널리 사용되는 **2의 보수 표현[^1]**으로, 이진수로 표현된 수를 반전시킨 후 1을 더하는 것이다.  
각 자릿수의 숫자가 0이면 1로, 1이면 0으로 바꾼 후, 반전된 숫자에 1을 더하면 2의 보수를 얻을 수 있다.

보수로 표현된 값의 원본 값을 알고 싶다면, 한번 더 2의 보수 표현을 사용하면 된다.

### 이진수에서 음수와 양수를 구별하는 법
컴퓨터는 `0b11`만 보고 이 수가 2의 보수로 표현된 값인지, 아니면 원본 값인지 알 수 없다.  
따라서 **플래그(flag)**를 사용해 음수/양수를 구별한다.

수가 표현될 때, 음수인지 양수인지 직접 표기하므로 컴퓨터는 더 이상 특정 수가 음수인지 양수인지 헷갈리지 않는다.

이 플래그는 데이터 표현시 **부호 비트**라는 곳에 한 자릿수를 차지하여 저장된다.  
부호 비트는 데이터 가장 앞자리에 위치해 있다.

### 2의 보수 표현의 한계
- 2의 보수 방법은 널리 사용되지만 완벽한 방식은 아니다.
- `0b0000`에 2의 보수를 취하면 → `0b0000` → `0b1111` → `0b10000` → 자리 올림된 비트를 버리면 `0b0000` (자기 자신)
- `0b1000`에 2의 보수를 취해도 마찬가지로 자기 자신이 됨

### 부울 대수란?
참, 거짓을 판별할 수 있는 논리적 명제를 수학적으로 표현한 논리이다.  
1854년 영국의 수학자 `조지 부울(George Boole)`이 제안함.

### 부울 대수의 기본 법칙

#### 결합 법칙  
![결합 법칙 이미지](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2F2f75afaa-e933-46a8-8999-8ed8a5ceacac%2Fimage.png)

#### 교환 법칙  
![교환 법칙 이미지](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2F148cace5-689e-4dec-8861-28d64d1cd2be%2Fimage.png)

#### 분배 법칙  
![분배 법칙 이미지](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2F81098789-8a2c-4cd2-8441-7893cfb69461%2Fimage.png)

#### 드모르간 법칙  
![드모르간 법칙 이미지](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2Fa1035e66-13ab-4844-9c70-9bbe1c1a4a5f%2Fimage.png)

### 논리식의 간편화
위의 규칙들을 활용하여 논리식을 간편화할 수 있으며, 다른 방법으로는 `카노맵(Karnaugh Map)`을 활용할 수 있다.

#### 기본 방법  
![간편화](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2F307ad5d1-dc85-49a6-b5ef-c5882d55283b%2Fimage.png)

#### 카노맵 (Karnaugh Map)
- 변수가 n개라면 2^n개의 minterm으로 구성된다
- 인접한 minterm은 하나의 변수만이 변경된다
- 출력이 1인 기본곱(minterm)에 해당하는 칸은 1, 나머지는 0으로 표시

![카노맵](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2Fb4181f8e-59f5-45d3-bd35-5698b98048fb%2Fimage.png)

#### 카노맵 예시  
![카노맵 활용 예시](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2F16001c8e-7634-404d-a928-49d623773cbe%2Fimage.png)


## 논리 게이트

논리 게이트는 부울 대수를 회로로 구현한 기본 논리 연산 장치이다.

### 기본 게이트

| 게이트 | 기호 | 동작 | 진리표 |
|--------|------|------|--------|
| AND    | ⋀    | 모두 1일 때만 1 | A B → A ⋀ B:<br>00→0, 01→0, 10→0, 11→1 |
| OR     | ⋁    | 하나라도 1이면 1 | A B → A ⋁ B:<br>00→0, 01→1, 10→1, 11→1 |
| NOT    | ¬    | 반전               | A → ¬A:<br>0→1, 1→0 |

### 응용 게이트
- **NAND**: AND 후 NOT → 모두 1일 때만 0
- **NOR**: OR 후 NOT → 모두 0일 때만 1
- **XOR**: 서로 다를 때만 1
- **XNOR**: 서로 같을 때만 1


## 조합 논리 회로

조합 논리 회로는 입력 조합에 따라 **즉시 출력**이 결정되며, 상태 기억 기능이 없다.

### 특징
- 기억 기능 없음
- 논리 게이트 조합으로 구현
- 입력에만 따라 출력이 결정

### 대표 회로

#### 반가산기 (Half Adder)
- 입력: A, B
- 출력: Sum = A ⊕ B, Carry = A ⋀ B

#### 전가산기 (Full Adder)
- 입력: A, B, Cin
- 출력: Sum = A ⊕ B ⊕ Cin  
Carry = (A ⋀ B) ⋁ (Cin ⋀ (A ⊕ B))

#### 인코더 / 디코더
- 인코더: 입력 중 하나만 1 → 해당 위치를 이진수로 출력
- 디코더: 이진수 입력 → 해당 위치만 1로 출력

#### 멀티플렉서 (MUX)
- 여러 입력 중 선택된 하나를 출력

#### 디멀티플렉서 (DEMUX)
- 하나의 입력 → 선택된 출력선으로 전달


## 순차 회로

순차 회로는 **이전 상태(메모리)**를 고려해 동작하며, 클럭에 따라 동작하는 경우가 많다.

### 특징
- 기억 기능 있음
- 상태 + 입력에 따라 출력이 결정됨
- 클럭(Clock) 기반 동작

### 구성 요소
- **래치(Latch)**: 입력 변화에 따라 즉시 상태 변화
- **플립플롭(Flip-Flop)**: 클럭 신호에 따라 상태 저장 (1비트 기억 장치)

### 대표 회로

#### 레지스터
- 여러 개의 플립플롭으로 구성된 데이터 저장 장치

#### 카운터
- 클럭에 따라 값 증가/감소

#### 상태 머신 (FSM)
- 입력과 현재 상태를 기반으로 다음 상태와 출력을 결정


## 출처
- *혼자 공부하는 컴퓨터 구조+운영체제*, 강민철 저, 한빛미디어

[^1]: 어떤 수를 그보다 큰 2의 n제곱에서 뺀 값 (ex: 2의 보수)
